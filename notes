#########
#Editor Config
#########
Set up the baseline decisions about tooling - we need a JavaScript editor
So everyone on our team uses the same critical editor settings, like spaces versus tabs, line endings, and more, by using a standard called editorconfig
1. Create the file with the settings
2. Some editor, like vscode, requires a plugin which have to be installed
(check https://editorconfig.org/)
That's all

#########
#Package Management
#########
Use NPM
create package.json which npm uses
npm install

#########
#Development Webserver
#########
options:
http-server
live-server
Express
budo
webpack dev server
browsersync

Using Express,
Already installed. see the packagejson file
From root directory, Create a folder 'buildScripts', which houses the srcServer.js file (where webserver is set up) serving a file
From root directory, create a folder 'src', in it create the file 'index.html'

#########
#Share Work In Progress
#########
Tools:
localtunnel: easy to share;
npm install localtunnel -g
start the app
lt --port 3000
lt --port 3000 --subdomain ezekiel //or sub domain of ezekiel

ngrok
sign up
install ngrok
install authtoken
start app
./ngrok http 80
//secutiry

now
quick depoly node.js to the cloud, hosting persists

npm install
create start script
now //no need to keep your files

surge
Quickly host static files
npm install
surge

#########
#Set Up Automation
#########
options
Grunt, Gulp, npm scripts

Declared in packagejson
leverage ur OS' command line
Directly use npm package
Call separate node scripts
convention-based pre/post hooks
leverage worlds largest package manager
why npm scripts?
Use tools Directly
No need for separate plugins
Simpler debudding
Better bugs
Esay to learn


decalred the scripts in packagejson
"start": "node buildScripts/srcServer.js"
"prestart": "node buildScripts/startMessage.js", //prestart will run before start, poststart will run after start
"localtunnel": "lt --port 3000" //npm run localtunnel
"share": "npm-run-all --parallel start localtunnel" //run 'start' and 'localtunnel' in parallel
"share": "npm-run-all --parallel start localtunnel -s" //run 'start' and 'localtunnel' in parallel, '-s' removes extraneous info

packages called from npm scripts do need to be installed globally


#########
# Transpiling
#########
Babel
Transpile the lastest innovations
Write standardized js
leveage full ES ecosystem
use experimental features earlier
ES6 imports are statically analyzable

Typescripts
Enhanced autocomplete
enhanced readerbility
safer refactory
additional non-standrd features

Babel
create a new file in root called .babelrc
basically this:
{
    "presets": [
        "latest"
    ]
}

In packagejson file: "prestart": "babel-node buildScripts/startMessage.js"; see the babel-node
so ES6 syntax in the startMessage script is transpilled

#########
# Bundling
#########
webpack

in root set up, webpack.config.dev.js

import webpack from 'webpack';
import path from 'path';

export default {
  debug: true, //want to see bugs and treat them
  devtool: 'inline-source-map',
  noInfo: false, // see files that are being bundled
  entry: [
    path.resolve(__dirname, 'src/index') //entry point for webpack
  ],
  target: 'web', //could target electron, or apps
  output: {
    path: path.resolve(__dirname, 'src'), //source of the producted virtual file generated by webpack
    publicPath: '/',
    filename: 'bundle.js' //name of the file
  },
  devServer: {
      contentBase: path.resolve(__dirname,'src')
  },
  plugins: [],
  module: {
    loaders: [
      {test: /\.js$/, exclude: /node_modules/, loaders: ['babel']},
      {test: /\.css$/, loaders: ['style','css']}
    ]
  }
};

index.js is created in src
the script tag is added to the index.html file
the server is configure to use webpack
**.babelrc is moved to root

to generate source map, we add 'debugger' to where we would like to debug

#########
#8 Linting
#########
Enforce consistency:
curly braces position
confirm/ alert
Trailing commas
Globals
eval

Avoid mistakes:
Extra parathesis
overwriting function
assignment in conditionals
missing default case in switch
debugger/ console.log

JsLint, JsHint, EsHint

Config. Location: Separate file, or packagejson
Rules to enable?
Warnings (can continue development) or errors(breaks the build)? use both?
Which plugins?
Use a preset? From scratch or the Recommended (w can tweaked based on feedback)

EsLInt does not watch files. solution? esint-loader or eslint-watch?
EsLint doesnt use experiemental features; to use, try babel-esint, remeber to use the necessary plugin


One place to check
Univerversal config
part of contnous integration

Set up EsLint
Eslint recommendation
Eslint watch

create .eslintrc.json
{
  "root": true, //declare as root
  "extends": [
    "eslint:recommended", //use the recommeded rule
    "plugin:import/errors", //lintin for imports
    "plugin:import/warnings"
  ],
  "parserOptions": {
    "ecmaVersion": 7,
    "sourceType": "module" //standard
  },
  "env": {
    "browser": true, //for global variables
    "node": true,
    "mocha": true
  },
  "rules": {
      "no-console": 1 //rules to overwrite; 1 warning, 2 error, 0 means off
  }
}

set to run with npm script...
it can run on its won, but we want to use it with eslint-watch, --color flag colors the warnings/errors
lint all webpack.config files (dev and pro) in src and buildScripts
"lint": "esw webpack.config.* src buildScripts --color"

npm run lint -s //run the script; -s flag removes nodejs npm ERR; remember to cd using the right case for the directory

in src sever, you dont care in build files, to disable: /*eslint-disable no-console */ at the top of the file

aliter:
at the end of a line // eslint-disable-line no-console

"lint:watch": "npm run lint -- --watch"// this says run the lint script, pass the --watch tag as well
use in start, so that it starts at starup


