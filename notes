#########
#Editor Config
#########
Set up the baseline decisions about tooling - we need a JavaScript editor
So everyone on our team uses the same critical editor settings, like spaces versus tabs, line endings, and more, by using a standard called editorconfig
1. Create the file with the settings
2. Some editor, like vscode, requires a plugin which have to be installed
(check https://editorconfig.org/)
That's all

#########
#Package Management
#########
Use NPM
create package.json which npm uses
npm install

#########
#Development Webserver
#########
options:
http-server
live-server
Express
budo
webpack dev server
browsersync

Using Express,
Already installed. see the packagejson file
From root directory, Create a folder 'buildScripts', which houses the srcServer.js file (where webserver is set up) serving a file
From root directory, create a folder 'src', in it create the file 'index.html'

#########
#Share Work In Progress
#########
Tools:
localtunnel: easy to share;
npm install localtunnel -g
start the app
lt --port 3000
lt --port 3000 --subdomain ezekiel //or sub domain of ezekiel

ngrok
sign up
install ngrok
install authtoken
start app
./ngrok http 80
//secutiry

now
quick depoly node.js to the cloud, hosting persists

npm install
create start script
now //no need to keep your files

surge
Quickly host static files
npm install
surge

#########
#Set Up Automation
#########
options
Grunt, Gulp, npm scripts

Declared in packagejson
leverage ur OS' command line
Directly use npm package
Call separate node scripts
convention-based pre/post hooks
leverage worlds largest package manager
why npm scripts?
Use tools Directly
No need for separate plugins
Simpler debudding
Better bugs
Esay to learn


decalred the scripts in packagejson
"start": "node buildScripts/srcServer.js"
"prestart": "node buildScripts/startMessage.js", //prestart will run before start, poststart will run after start
"localtunnel": "lt --port 3000" //npm run localtunnel
"share": "npm-run-all --parallel start localtunnel" //run 'start' and 'localtunnel' in parallel
"share": "npm-run-all --parallel start localtunnel -s" //run 'start' and 'localtunnel' in parallel, '-s' removes extraneous info

packages called from npm scripts do need to be installed globally


#########
# Transpiling
#########
Babel
Transpile the lastest innovations
Write standardized js
leveage full ES ecosystem
use experimental features earlier
ES6 imports are statically analyzable

Typescripts
Enhanced autocomplete
enhanced readerbility
safer refactory
additional non-standrd features

Babel
create a new file in root called .babelrc
basically this:
{
    "presets": [
        "latest"
    ]
}

In packagejson file: "prestart": "babel-node buildScripts/startMessage.js"; see the babel-node
so ES6 syntax in the startMessage script is transpilled

#########
# Bundling
#########
webpack

in root set up, webpack.config.dev.js

import webpack from 'webpack';
import path from 'path';

export default {
  debug: true, //want to see bugs and treat them
  devtool: 'inline-source-map',
  noInfo: false, // see files that are being bundled
  entry: [
    path.resolve(__dirname, 'src/index') //entry point for webpack
  ],
  target: 'web', //could target electron, or apps
  output: {
    path: path.resolve(__dirname, 'src'), //source of the producted virtual file generated by webpack
    publicPath: '/',
    filename: 'bundle.js' //name of the file
  },
  devServer: {
      contentBase: path.resolve(__dirname,'src')
  },
  plugins: [],
  module: {
    loaders: [
      {test: /\.js$/, exclude: /node_modules/, loaders: ['babel']},
      {test: /\.css$/, loaders: ['style','css']}
    ]
  }
};

index.js is created in src
the script tag is added to the index.html file
the server is configure to use webpack
**.babelrc is moved to root

to generate source map, we add 'debugger' to where we would like to debug
